

* Change log

Every section in this part lists the change of the versions

The dictionary will make use of the var format for retaining any type of
data. This will allow for greater structure etc.

** Added dealloc specifier for delete <2014-10-19 Sun>
When deleting a dictionary, or key in dictionary one
can now only delete the reference. 
This is handy if the <key>.kvp.<val> has been used.
Also improved specific key deletion by adding a 
hash-check.

** Added .NIN. and .VALP. routines <2014-10-19 Sun>
Added a function to check for keys not in a dictionary.
Added a value retriever which transfers the pointer, and not
the value.
** Converted data container to a single byte array <2014-07-31 Thu>
By using a trick of transferring types with pointers we only pass
the direct information in the type (i.e. variable placement in
memory etc).
With this method we can hold any type of variable as the type
is saved via an encoding realised as:

 type :: ptr
   real, pointer :: p(:)
 end type ptr
 type(ptr) :: p
 character(len=1), allocatable :: enc(:)
 real :: a(2)
 
 allocate(enc(size(transfer(a,p)))
 enc = transfer(a,p)

which tells the encoding the placement of the data.

** Changed required BASH version to 3 for compilation <2014-06-10 Tue>
The required BASH version was version 4+.
However, as many Macs are still relying on very old BASH 3 it has
been decided to change the compilation compatibility to BASH 3.

** Added information to printout statement <2014-05-30 Fri>
Printing the dictionary now also shows the datatype along with
the hash. The format:
  <key> [<data-type>] (<hash-value>)
is utilised

** Created a generic routine for deletes <2014-05-30 Fri>
In the dictionary several places of the code utilises a formation
of checking deletion/nullification of the out/in-going variable.
Now a generic subroutine can handle this.

** Can now assign a dictionary without specifying a key <2014-05-30 Fri>
I had forgotten to enable direct assignment "call assign(val,dic)"
this has been fixed.

** Added a which(this,key) for the dictionary <2014-05-30 Fri>
It enables a direct look on the data type to assert without 
having to fetch to a type(var)

** Renamed add => extend <2014-05-30 Fri>
This follows better the dictionary terminology.
I think extend is better than append as the latter implies
an "end"-appendage.

** Renamed dict_print => print <2014-05-30 Fri>
We might as well use a common print function.
It has been overloaded to enable other codes to also
utilise the print routine name.

** Bugfix for associating <2014-05-30 Fri>
The default associating a type(var) with type(var)
is to not deallocate.
This was a bug and has been fixed. It now behaves correctly.

** Added print function to variable <2014-05-30 Fri>
Only prints out the data type for now,
consider adding a field to hold the size of the variable.
That would also allow calling size on type(var)

** Added the variable data type <2014-05-28 Wed>
The data type type(var) has been added to the dictionary.

** Renamed character data type <2014-05-28 Wed>
The character data type was added using a non-conforming name,
I have renamed the function calls for both the variable and the
dictionary code.

** Direct creation of dictionaries not allowed <2014-05-25 Sun>
For calling routines:
  call routine('hello'.kv.'h')
we have a memory leak. This is obvious due to the pointer
nature of the data associated. 
A test has been added to demonstrate this effect:
  tst_dict_mem3

** Renamed .HAS. to .IN. <2014-05-25 Sun>
A more appropriate name has been chosen for checking 
existence of keys in dictionaries. Much like python we
rely on the <key> .IN. <dict> to check for the existence.

** Same value keys are (assign)ed <2014-05-25 Sun>
In case a dictionary key with the same name
is added to an existing dictionary we delete the old one
by doing an "assign".
This is the expected behaviour in any language.

** Rely on libvar.a rather than chars <2013-11-11 Mon>
The dictionary values are now the type(var) which eases
the interfacing between different segments of the code.
We allow to fully utilise the "assign" and "associate"
function calls in the assignment of the dictionary by following the 
operators:
   .KV. (assign)
   .KPV. (associate)

